1. Create a utility file utils/validation_utils.py
import logging
from email.utils import parseaddr
from django.core.validators import validate_email
from django.core.exceptions import ValidationError

# Setup logger for debugging (optional)
logger = logging.getLogger(__name__)

def is_valid_email(email: str) -> bool:
    """
    Validate an email address using Python/Django's built-in tools.
    Returns True if valid, False otherwise.
    """
    if not email:
        return False

    try:
        # Basic structural validation using parseaddr
        parsed_name, parsed_email = parseaddr(email)
        if not parsed_email:
            return False

        # Django's strict validation
        validate_email(parsed_email)
        return True
    except ValidationError:
        logger.warning(f"Invalid email attempted: {email}")
        return False
    except Exception as e:
        logger.error(f"Unexpected error validating email {email}: {str(e)}")
        return False

2. Example usage in a view (users/views.py or any form-handling view)
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import status
from utils.validation_utils import is_valid_email

class EmailValidationView(APIView):
    def post(self, request):
        email = request.data.get("email")

        if not is_valid_email(email):
            return Response({"error": "Invalid email address"}, status=status.HTTP_400_BAD_REQUEST)

        return Response({"message": "Valid email!"}, status=status.HTTP_200_OK)

3. Example test in Django shell
python manage.py shell

from utils.validation_utils import is_valid_email

print(is_valid_email("test@example.com"))  # ✅ True
print(is_valid_email("bad-email@"))        # ❌ False
