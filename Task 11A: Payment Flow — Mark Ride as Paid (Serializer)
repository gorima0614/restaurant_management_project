✅ 1. Update the Ride model (rides/models.py)
from django.db import models
from django.utils import timezone

class Ride(models.Model):
    STATUS_CHOICES = [
        ('REQUESTED', 'Requested'),
        ('ONGOING', 'Ongoing'),
        ('COMPLETED', 'Completed'),
        ('CANCELLED', 'Cancelled'),
    ]

    PAYMENT_STATUS_CHOICES = [
        ('PAID', 'Paid'),
        ('UNPAID', 'Unpaid'),
    ]

    PAYMENT_METHOD_CHOICES = [
        ('CASH', 'Cash'),
        ('UPI', 'UPI'),
        ('CARD', 'Card'),
    ]

    customer = models.CharField(max_length=100)
    driver = models.CharField(max_length=100)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='REQUESTED')
    fare = models.DecimalField(max_digits=8, decimal_places=2, default=0)

    # Payment tracking
    payment_status = models.CharField(
        max_length=10, choices=PAYMENT_STATUS_CHOICES, default='UNPAID'
    )
    payment_method = models.CharField(
        max_length=10, choices=PAYMENT_METHOD_CHOICES, null=True, blank=True
    )
    paid_at = models.DateTimeField(null=True, blank=True)

    def mark_as_paid(self, method):
        """Helper method to mark ride as paid."""
        if self.status != 'COMPLETED':
            raise ValueError("Ride must be completed before marking payment.")
        if self.payment_status == 'PAID':
            raise ValueError("Ride is already marked as paid.")
        self.payment_status = 'PAID'
        self.payment_method = method
        self.paid_at = timezone.now()
        self.save()

    def __str__(self):
        return f"Ride #{self.id} - {self.status} - {self.payment_status}"

✅ 2. Create a Payment Serializer (rides/serializers.py)
from rest_framework import serializers
from django.utils import timezone
from .models import Ride


class RidePaymentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Ride
        fields = ["payment_method", "payment_status"]

    def validate(self, data):
        ride = self.instance  # The Ride being updated

        # Rule 1: Only completed rides can be marked as paid
        if data.get("payment_status") == "PAID" and ride.status != "COMPLETED":
            raise serializers.ValidationError(
                "Payment can only be marked as PAID if the ride is COMPLETED."
            )

        # Rule 2: Prevent changing if already paid
        if ride.payment_status == "PAID":
            raise serializers.ValidationError("Ride is already marked as PAID.")

        return data

    def update(self, instance, validated_data):
        payment_status = validated_data.get("payment_status")
        payment_method = validated_data.get("payment_method")

        if payment_status == "PAID":
            instance.payment_status = "PAID"
            instance.payment_method = payment_method
            instance.paid_at = timezone.now()
        else:
            # Allow marking unpaid (resetting method + paid_at)
            instance.payment_status = "UNPAID"
            instance.payment_method = None
            instance.paid_at = None

        instance.save()
        return instance

✅ 3. Create the API View (rides/views.py)
from rest_framework import generics
from rest_framework.response import Response
from rest_framework import status
from .models import Ride
from .serializers import RidePaymentSerializer


class RidePaymentUpdateView(generics.UpdateAPIView):
    queryset = Ride.objects.all()
    serializer_class = RidePaymentSerializer
    lookup_field = "pk"

    def post(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

✅ 4. Add URL (rides/urls.py)
from django.urls import path
from .views import RidePaymentUpdateView

urlpatterns = [
    path("ride/payment/<int:pk>/", RidePaymentUpdateView.as_view(), name="ride-payment"),
]

✅ 5. Example Request
POST /api/ride/payment/42/
Content-Type: application/json

{
  "payment_method": "CASH",
  "payment_status": "PAID"
}

✅ Example Response
{
  "payment_method": "CASH",
  "payment_status": "PAID"
}
